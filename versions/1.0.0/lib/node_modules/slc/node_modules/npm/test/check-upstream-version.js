/*
 * This script fetches the version of npm shipped in the latest node
 * version satisfying nodeSemver and exits with non-zero status code
 * when this version is ahead of the version of this module.
 */

// semver specification of the node version we would like to track
var nodeSemver = '0.10.x';

//----- Implementation -----

var fs = require('fs');
var https = require('https');
var semver = require('semver');

exitIfInBranch();

var ourVersion = require('../package.json').version;
console.log('our version is %s', ourVersion);

fetchLatestVersionTag(nodeSemver, function(tag) {
  // console.log('latest node version tag for %s: %s', nodeSemver, tag.ref);
  fetchNpmVersion(tag.object.sha, function(upstreamVersion) {
    console.log(
      'npm version in the latest node %s: %s',
      nodeSemver,
      upstreamVersion
    );

    // strip out the version of our fork
    var ourVersionBase = ourVersion.replace(/-.*$/, '');

    if (semver.lt(ourVersionBase, upstreamVersion)) {
      console.log(
        [
          'Our fork is behind the version shipped in the latest node release.',
          'Please merge the changes from upstream to bring it up to date.'
        ].map(function(l) { return 'ERROR ' + l; }).join('\n')
      );
      process.exit(1);
    }
  });
});

//----- Helper functions -----

function exitIfInBranch() {
  var gitHead = fs.readFileSync(__dirname + '/../.git/HEAD').toString().trim();
  if (gitHead != 'ref: refs/heads/master') {
    console.log('Skipping check of upstream version for non-master HEAD');
    console.log('    ' + gitHead);
    process.exit(0);
  }
}

function fetchNpmVersion(sha, cb) {
  var url = 'https://api.github.com/repos/joyent/node/git/trees/' +
    sha + '?recursive=1';

  // console.log('npm url: %s', url);

  requestJson(url, readTreeResponse);

  function readTreeResponse(tree) {
    // console.log('tree: %j', tree);
    var npmPackageJson = tree.tree.filter(function(entry) {
      return entry.path == 'deps/npm/package.json';
    })[0];
    requestJson(npmPackageJson.url, parseJsonBlob);
  }

  function parseJsonBlob(blob) {
    var binaryContent = new Buffer(blob.content, blob.encoding);
    var data = JSON.parse(binaryContent.toString());
    cb(data.version);
  }
}

function fetchLatestVersionTag(semverSpec, cb) {
  requestJson(
    'https://api.github.com/repos/joyent/node/git/refs/tags',
    findVersionInTags
  );

  function findVersionInTags(tags) {
    var prefix = 'refs/tags/v';

    var versionTags = tags.filter(function(t) {
      return t.ref.substr(0, prefix.length) == prefix;
    });
    var versions = versionTags.map(function(t) {
      return t.ref.substr(prefix.length);
    });
    // console.log('node versions: %j', versions);

    var latestVersion = semver.maxSatisfying(versions, semverSpec);
    var latestTag = tags.filter(function(t) {
      return t.ref == prefix + latestVersion;
    })[0];
    // console.log('latest version: %s %j', latestVersion, latestTag);

    cb(latestTag);
  }
}

function requestJson(url, cb) {
  https.request(url, readTagsResponse).end();

  function readTagsResponse(resp) {
    var body = '';
    resp.on('data', function(chunk) {
      body += chunk.toString();
    });
    resp.on('end', function() {
      cb(JSON.parse(body));
    });
  }
}
