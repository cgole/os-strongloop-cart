
module.exports.MultiRegClient = MultiRegClient
module.exports.getConfig = getConfig;
module.exports.createClient = createClient;

var RegClient = require('npm-registry-client'),
    parseUrl = require('url').parse,
    format = require('util').format,
    npmlog = require('npmlog'),
    merge = require('./merge.js');

try {
  npmlog = require("npmlog")
} catch (er) {
  npmlog = { error: noop, warn: noop, info: noop,
             verbose: noop, silly: noop, http: noop,
             pause: noop, resume: noop }
}

function noop () {}


function RegConf(base, specific) {
  function get(key) {
    var val;

    if (key === 'registry') {
      if (typeof specific.get === 'function')
        return specific.get('url');
      else
        return specific.url;
    }

    if (typeof specific.get === 'function')
      val = specific.get(key);
    else
      val = specific[key];

    if (val !== undefined)
      return val;

    if (typeof base.get === 'function')
      return base.get(key);
    else
      return base[key];
  }

  function set(key, value) {
    if (typeof specific.set === 'function')
      specific.set(key, value);
    else
      specific[key] = value;
    }

  function del(key) {
    if (typeof specific.del === 'function')
      specific.del(key);
    else
      delete specific[key];

    if (typeof base.del === 'function')
      base.del(key);
    else
      delete base[key];
  }

  this.get = get;
  this.set = set;
  this.del = del;
}


function wrapConfigObject(conf) {
  // accept either a plain-jane object, or a npmconf object
  // with a "get" method.
  if (typeof conf.get !== 'function') {
    var data = conf
    conf = { get: function (k) { return data[k] }
           , set: function (k, v) { data[k] = v }
           , del: function (k) { delete data[k] } }
  }

  return conf;
}

function MultiRegClient(conf) {
  conf = wrapConfigObject(conf);

  var log = conf.get('log') || npmlog;

  var registry = conf.get('registry');
  if (typeof registry !== 'object')
    throw new Error("Configuration doesn't specify multiple registries");

  var registries = [];

  for (var name in registry) {
    if (!registry.hasOwnProperty(name))
      continue;

    var regConf = new RegConf(conf, registry[name]),
        client = new RegClient(regConf);

    registries.push({
      name: name,
      conf: regConf,
      client: client
    });
  }

  this.conf = conf;
  this.log = log;
  this.registries = registries;

  this.get = getImplementation(this, 'get', 'install', true);
  this.publish = getImplementation(this, 'publish', 'publish', false);
  this.adduser = getImplementation(this, 'adduser', 'publish', false);
  this.request = getImplementation(this, 'request', 'publish', false);
  this.star = getImplementation(this, 'star', 'install', true);
  this.tag = getImplementation(this, 'tag', 'publish', false);
  this.unpublish = getImplementation(this, 'unpublish', 'publish', false);
  this.upload = getImplementation(this, 'upload', 'publish', false);
}

function getImplementation(self, method, purpose, tryMultiple) {
  // Compute the order in which registries are tried.

  function getPriority(registry) {
    var priority;

    if (purpose)
      priority = registry.conf.get(purpose + '-priority');

    if (priority === undefined)
      priority = registry.conf.get('priority');

    if (priority === undefined)
      priority = 1;

    return +priority;
  }

  var registries = self.registries.filter(function(registry) {
    return getPriority(registry) >= 0;
  });

  registries.sort(function(reg1, reg2) {
    return getPriority(reg2) - getPriority(reg1);
  });

  // If trying multiple registries isn't applicable to the method, just
  // return the implementation method for the specific registry.
  if (!tryMultiple) {
    var client = registries[0].client;
    return client[method].bind(client);
  } else if (method == 'get') {
    return multiget;
  } else {
    return wrapper;
  }

  function wrapper() {
    // Replace callback by wrapper callback that tries multiple repos.
    var args = Array.prototype.slice.call(arguments),
        originalCallback = args[args.length - 1];
    args[args.length - 1] = wrapperCallback;

    // Start at the registry with the highest priority.
    var registryIndex = 0;
    callClient();

    function callClient() {
      var client = registries[registryIndex].client;
      client[method].apply(client, args);
    }

    function wrapperCallback(err) {
      if (err && err.code === 'E404' &&
          registryIndex < registries.length - 1) {
        self.log.info('retry',
                      format("not found in '%s', now trying '%s' registry",
                             registries[registryIndex].name,
                             registries[registryIndex + 1].name));
        registryIndex++;
        return callClient();
      }

      originalCallback.apply(this, arguments);
    }
  }

  function multiget(what) {
    if (what.indexOf('/') != -1) {
      return wrapper.apply(null, arguments);
    }

    // Create a copy of arguments, we will replace callback by wrapper
    // callback that merges multiple repos
    var args = Array.prototype.slice.call(arguments);
    var originalCallback = args[args.length - 1];

    var responses = new Array(registries.length);
    var responseCount = 0;
    var wasError = false;
    var wasFound = false;
    var notFoundError;

    registries.forEach(function(reg, ix) {
      args[0] = what;
      if (reg.conf.get('registry') !== 'https://registry.npmjs.org/') {
        // force unique cache key for all registries except the community one
        args[0] += args[0].indexOf('?') !== -1 ? '&' : '?';
        args[0] += 'src=' + encodeURIComponent(reg.name);
      }

      args[args.length - 1] = multiCallback(ix);

      var client = reg.client;
      client[method].apply(client, args);
    });

    function multiCallback(registryIndex) {
      return function(err, remoteData) {
        if (wasError) return;
        if (err) {
          if (err.code !== 'E404') {
            originalCallback(err);
            wasError = true;
            return;
          }
          notFoundError = err;
          remoteData = {};
        } else {
          wasFound = true;
        }

        responses[registryIndex] = remoteData;
        responseCount++;
        if (responseCount == registries.length) {
          if (!wasFound) {
            originalCallback(notFoundError || new Error('Not found'));
            return;
          }
          var data = merge(responses);
          originalCallback(null, data);
        }
      }
    }
  }
}

function getConfig(conf, url) {
  conf = wrapConfigObject(conf);

  // If there's just one registry defined, use the global config object.
  if (!(conf.get('registry') instanceof Object))
    return conf;

  // If multiple registries are defined, find the registry associated with this
  // particular url.
  var registries = conf.get('registry');

  if (typeof url !== 'object')
    url = parseUrl(url);

  for (var key in registries) {
    if (!registries.hasOwnProperty(key))
      continue;

    var regConf = new RegConf(conf, registries[key]),
        regUrl = parseUrl(regConf.get('registry'));

    if (url.host == regUrl.host &&
        url.path.indexOf(regUrl.path) === 0)
      return regConf;
  }

  // No registry found for given URL. This usually happens when installing
  // package using an explicit URL, e.g. from Reggie registry.
  var dummyRegistry = { url: 'http://example.com/', priority: -1000 };
  return new RegConf(conf, dummyRegistry);
}


function createClient(conf) {
  var conf = wrapConfigObject(conf);

  if (!(conf.get('registry') instanceof Object))
    return new RegClient(conf);
  else
    return new MultiRegClient(conf);
}
